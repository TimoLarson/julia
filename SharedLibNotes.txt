====
Using a combination of "--output-so file.so" and "precompile" calls
to drive llvm code generation to create a compilecache shared library
from a package.
====

compilecache <base/loading.jl>
    Call create_expr_cache

create_expr_cache <base/loading.jl>
    Call julia_cmd specifying "--output-so file.so" on the command line

<src/jloptions.c>
    Set variables based on "--output-so file.so" on command line

<source_of_pkg_having_compilecache_being_built.jl>
    Call precompile on some of its functions

precompile <base/essentials.jl>
    Call jl_compile_hint to do its work

jl_compile_hint <src/gf.c>
    Increment in_compile_hint
    Trigger compilation of a function to the shadow_output llvm module
    Decrement in_compile_hint

jl_compile_hint -> jl_compile_now ->
    _generate_from_hint -> jl_compile_linfo ->
    jl_finalize_module -> jl_add_to_shadow

jl_add_to_shadow <src/jitlayers.cpp>
    Add to shadow_output if jl_options.outputso && in_compile_hint > 0

jl_atexit_hook <src/init.c>
    Call jl_write_compiler_output to output contents of shadow_output

jl_write_compiler_output <src/precompile.c>
    Call jl_shadow_output_to_bc for debugging
    Consider calling jl_dump_native to compile shadow_module
    [BTW: This calls jl_compile_hint for the __init__ of various modules]

jl_shadow_output_to_bc <src/codegen.cpp, src/julia_internal.h>
    Dump shadow_output as an llvm bc file for debugging
    [Check this to see what functions are getting compiled.]
        cd ~/pkg/src/puddle
        ~/pkg/git/julia_build/usr/tools/llvm-dis shadow.bc
        vim shadow.ll

jl_dump_native <src/jitlayers.cpp>
    Consider using this to compile contents of shadow_module to a shared library

in_compile_hint may need a counter to handle recursion

Implement:
* loading of shared library (e.g. vi dlopen)
* linking of shared library to loaded ji code (e.g using dlsym and attaching
      to invoke and specsomething. It would be nice if we could trick the
      existing linker into doing this for us.)
      [If the ji saved actual numbered function names then the deserialization
      step could potentially do this linking.]
* compiling of global variables
* compiling of types?

